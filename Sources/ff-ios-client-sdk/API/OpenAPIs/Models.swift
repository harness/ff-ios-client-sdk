// Models.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation

protocol JSONEncodable {
    func encodeToJSON() -> Any
}

public enum ErrorResponse : Error {
    case error(Int, Data?, Error?)
}

public enum DownloadException : Error {
    case responseDataMissing
    case responseFailed
    case requestMissing
    case requestMissingPath
    case requestMissingURL
}

public enum DecodableRequestBuilderError: Error {
    case emptyDataResponse
    case nilHTTPResponse
    case unsuccessfulHTTPStatusCode
    case jsonDecoding(DecodingError)
    case generalError(Error)
}

public enum CFErrors: Error {
	case storageError
}

public struct ErrorData
{
	public var title:String?
	public var localizedMessage: String?
	public let underlyingError: String?
	public let statusCode: Int?
	public let data: Data?
	init(title: String? = nil, localizedMessage: String?, underlyingError: String?, statusCode: Int?, data: Data?) {
		self.title = title
		self.localizedMessage = localizedMessage
		self.underlyingError = underlyingError
		self.statusCode = statusCode
		self.data = data
	}
	public static var defaultData: ErrorData {
		return ErrorData(localizedMessage: nil, underlyingError: nil, statusCode: nil, data: nil)
	}
}

public enum CFError: Error {
	case authError(ErrorResponse) //101
	case serverError(ErrorResponse) //102
	case parsingError // 103
	case noDataError // 104
	case storageError // 105
	case streamError(StreamError) //106
	case cacheError(CfCacheError)
  case error(any Error)

	public var errorData: ErrorData {
		switch self {
			case .authError(let errorResponse):
				var errorData = self.parseErrorResponse(errorResponse)
				errorData.title = "Authentication Error"
				return errorData
				
			case .serverError(let errorResponse):
				var errorData = self.parseErrorResponse(errorResponse)
				errorData.title = "Server Error"
				return errorData
				
			case .parsingError:
				var errorData = self.parseErrorResponse(nil)
				errorData.title = "Parsing Error"
				return errorData
				
			case .noDataError:
				var errorData = self.parseErrorResponse(nil)
				errorData.title = "No Data Error"
				return errorData
				
			case .storageError:
				var errorData = self.parseErrorResponse(nil)
				errorData.title = "Storage Error"
				return errorData
				
			case .streamError(let streamError):
				let errorData = self.parseStreamError(streamError)
				return errorData
				
			case .cacheError(let cacheError):
				var errorData = self.parseCacheError(cacheError)
				errorData.title = "Caching Error"
				return errorData


      case .error(let error):
      return ErrorData(localizedMessage: "Error: " + String(describing: error), underlyingError: nil, statusCode: nil, data: nil)
      }
	}
	
	private func parseErrorResponse(_ errorResponse: ErrorResponse?) -> ErrorData {
		guard let errorResponse = errorResponse else {return ErrorData.defaultData}
		switch errorResponse {
			case let .error(statusCode, data, error):
				return ErrorData(localizedMessage: error?.localizedDescription ?? "", underlyingError: error.debugDescription, statusCode: statusCode, data: data)
		}
	}
	private func parseStreamError(_ streamError: StreamError?) -> ErrorData {
		guard let streamError = streamError else {return ErrorData.defaultData}
		switch streamError {
			case .couldNotCreateCFEventSourceInstance:
				return ErrorData(localizedMessage: "Could not create CFEventSource instance", underlyingError: nil, statusCode: nil, data: nil)
			case .streamNotEnabled:
				return ErrorData(title: "Stream is not enabled", localizedMessage: nil, underlyingError: nil, statusCode: nil, data: nil)
			case .unableToConnect(let reason):
				switch reason {
					case .connectionCancelled:
						return ErrorData(title: "Stream cancelled", localizedMessage: "Connection was cancelled", underlyingError: nil, statusCode: StreamError.UnableToConnectReason.connectionCancelled.rawValue, data: nil)
					case .networkLost:
						return ErrorData(title: "Network lost", localizedMessage: "Network connection was lost", underlyingError: nil, statusCode: StreamError.UnableToConnectReason.networkLost.rawValue, data: nil)
					case .offline:
						return ErrorData(title: "Offline", localizedMessage: "Connection is offline", underlyingError: nil, statusCode: StreamError.UnableToConnectReason.offline.rawValue, data: nil)
					case .unknown:
						return ErrorData(title: "Unknown", localizedMessage: "Stream was cancelled", underlyingError: nil, statusCode: StreamError.UnableToConnectReason.unknown.rawValue, data: nil)
				}
		}
	}
	
	private func parseCacheError(_ cacheError: CfCacheError?) -> ErrorData {
		guard let cacheError = cacheError else {return ErrorData.defaultData}
		switch cacheError {
			case .fileAlreadyExists:
				return ErrorData(localizedMessage: "File Already Exists", underlyingError: nil, statusCode: nil, data: nil)
			case .fileDoesNotExist:
				return ErrorData(localizedMessage: "File Does Not Exist", underlyingError: nil, statusCode: nil, data: nil)
			case .invalidDirectory:
				return ErrorData(localizedMessage: "Invalid Directory", underlyingError: nil, statusCode: nil, data: nil)
			case .writingToCacheFailed:
				return ErrorData(localizedMessage: "Writing To Cache Failed", underlyingError: nil, statusCode: nil, data: nil)
			case .readingFromCacheFailed:
				return ErrorData(localizedMessage: "Reading From Cache Failed", underlyingError: nil, statusCode: nil, data: nil)
			case .writingToDiskFailed:
				return ErrorData(localizedMessage: "Writing To Disk Failed", underlyingError: nil, statusCode: nil, data: nil)
			case .readingFromDiskFailed:
				return ErrorData(localizedMessage: "Reading From Disk Failed", underlyingError: nil, statusCode: nil, data: nil)
		}
	}
}

public enum CfCacheError: Error {
	case fileAlreadyExists
	case fileDoesNotExist
	case invalidDirectory
	case writingToCacheFailed
	case readingFromCacheFailed
	case writingToDiskFailed
	case readingFromDiskFailed
}

public enum StreamError: Error {
	case streamNotEnabled
	case couldNotCreateCFEventSourceInstance
	case unableToConnect(UnableToConnectReason)
	
	
	public enum UnableToConnectReason {
		case offline
		case connectionCancelled
		case networkLost
		case unknown
		
		init(code: Int) {
			switch code {
				case -999: self = .connectionCancelled
				case -1009: self = .offline
				case -1005: self = .networkLost
				default: self = .unknown
			}
		}
		
		var rawValue: Int {
			switch self {
				case .connectionCancelled: return -999
				case .offline: return -1009
				case .networkLost: return -1005
				case .unknown: return 0
			}
		}
	}
}

open class Response<T> {
    public let statusCode: Int
    public let header: [String: String]
    public let body: T?

    public init(statusCode: Int, header: [String: String], body: T?) {
        self.statusCode = statusCode
        self.header = header
        self.body = body
    }

    public convenience init(response: HTTPURLResponse, body: T?) {
        let rawHeader = response.allHeaderFields
        var header = [String:String]()
        for (key, value) in rawHeader {
            if let key = key as? String, let value = value as? String {
                header[key] = value
            }
        }
        self.init(statusCode: response.statusCode, header: header, body: body)
    }
}
